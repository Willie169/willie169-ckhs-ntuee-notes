\documentclass[a4paper,12pt]{report}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{3}
\input{/usr/share/latex-toolkit/template.tex}
\begin{document}
\title{Switching Circuits and Logic Design}
\author{沈威宇}
\date{\temtoday}
\titletocdoc
\chapter{Switching Circuits and Logic Design}
\section{Introduction: Number Systems and Conversion}
\subsection{Digital Systems and Switching Circuits}
\begin{itemize}
\item\textbf{Digital system}: Deals with signals that have discrete values. Theoretically, for a given input, the output is exactly correct.
\item\textbf{Analog system}: Deals with signals that vary continuously over time. The output might have an error depending on the accuracy of the components used.
\item\textbf{System design}: The highest level of the design of digital systems, where you break the system into subsystems, specify what each subsystem do, and determine the interconnection and control of the subsystems.
\item\textbf{Logic design}: The middle level of the design of digital systems, where you specify the logic operations inside each subsystem.
\item\textbf{Circuit design}: The lowest level of the design of digital systems, where you specify the electronic components and their interconnection to form the system.
\item\textbf{Switching circuit}: A switching circuit has one or more inputs and one or more outputs which take on discrete values. Many of a digital system’s subsystems take the form of a switching circuit.
\item\textbf{Combinational circuit}: A circuit whose output value depends only on the present input value.
\item\textbf{Sequential circuit}: A circuit whose output value depends on the present input value and past input values.
\item\textbf{Logic gate}: An electronic device that performs a basic Boolean operation on one or more binary inputs (0 or 1) to produce a single binary output (0 or 1).
\end{itemize}
\subsection{Number Systems}
\subsubsection{Definition}
Let $b\in\mathbb{N}\land b>1$. A number with digits $d_n d_{n-1} \dots d_1 d_0$ in base (or radix) $b$ represents the value:
\[N = d_n \cdot b^n + d_{n-1} \cdot b^{n-1} + \dots + d_1 \cdot b^1 + d_0 \cdot b^0\]
where each $d_i \in \mathbb{Z}\land 0\leq d_i<b$.
\subsubsection{Conversion}
Suppose you have a number written in base $N$ (with $N\in\mathbb{N}\land N>1$):
\[(d_k d_{k-1} \dots d_1 d_0)_N\]
To convert it into base $M$ (with $M\in\mathbb{N}\land M>1$), we can repeatedly divide the number by $M$ and record the remainders until the quotient is $0$, then the digits in base $M$ are the remainders read from last to first.
\sssc{Special cases}
There is an easier way for conversion Between base $b$ and base $b^n$ (with $b\in\mathbb{N}\land b>1$):
\ben
\item Base $b$ to Base $b^n$:
\ben
\item Group the digits of the base-$b$ number into blocks of $n$ digits, starting from the LSB.
\item Convert each block to its equivalent single digit in base $b^n$.
\item Concatenate the bits.
\een
\item Base $b^n$ to Base $b$:
\ben
\item Convert each digit of the base-$b^n$ number to $n$ digits in base $b$.
\item Concatenate the $n$-digit blocks.
\een
\subsection{Binary}
A binary digit is called a bit, which is either $0$ or $1$. Binary arithmetic is the same as decimals, except that "invert" or "flip" means converting $0$ to $1$ and $1$ to $0$, and "complement" means inverting all bits.

The most significant bit (MSB) or most significant digit is the bit with the highest value place in a binary number and is the leftmost bit in standard binary notation; the least significant bit (LSB) or least significant digit is the bit with the lowest value place in a binary number and is the rightmost bit in standard binary notation.

$4$ bits is called a nibble; $8$ bits is called a byte.

A binary prefix is a unit prefix that indicates a multiple of a unit of measurement by an integer power of two. They are most often used in information technology as multipliers of bit and byte, in which the short prefixes are prefixed before b (representing bits) or B (representing bytes), and the long prefixes are prefixed before bits or bytes.
\begin{longtable}[c]{|c|c|c|}
\hline
Value & IEC (short) & IEC (long) & JEDEC (short) & JEDEC (long)\\\hline
$1024$ & Ki & kibi & K & kilo\\\hline
$1024^2$ & Mi & mebi & M & mega\\\hline
$1024^3$ & Gi & gibi & G & giga\\\hline
$1024^4$ & Ti & tebi & T & tera\\\hline
$1024^5$ & Pi & pebi & —\\\hline
$1024^6$ & Ei & exbi & —\\\hline
$1024^7$ & Zi & zebi & —\\\hline
$1024^8$ & Yi & yobi & —\\\hline
$1024^9$ & Ri & robi & —\\\hline
$1024^10$ & Qi & quebi & —\\\hline
\end{longtable}\FB
\subsection{Signed Number}
Suppose you have $N$ bit, to present a signed number, there's three common method:
\sssc{Sign and magnitude}
The MSB represents sign, in which $0$ represents positive and $1$ represents negative; the remaining represents magnitude. 

It can represent numbers range from $-(2^{N-1}-1)$ to $2^{N-1}-1$. It has two zero ($+0$ and $-0$).

It is the easiest to read, but its arithmetic is the hardest to compute.
\sssc{1’s complement}
The nonnegative numbers are the same as those in sign and magnitude; the negative numbers invert all bits of its absolute value. 

It can represent numbers range from $-(2^{N-1}-1)$ to $2^{N-1}-1$. It has two zero ($+0$ and $-0$). 

Its arithmetic is easier than sign and magnitude and harder than 2’s complement to compute. 

The addition can be computed the same as unsigned numbers; however, if the sum had a carry out from the MSB, we must add it back to the LSB, called the "end-around carry".
\begin{proof}\mbox{}\\
Assume no overflow conditions.

An $n$-bit negative number $X$ is represent as $2^n-1-|X|$ in 1’s complement.

When we add two $n$-bit numbers $A$ and $B$, with 1’s complement representations $A_1$ and $B_1$.

Let:
\[S = A_1 + B_1,\quad R=S \mod 2^n, \quad C=\left\lfloor \frac{S}{2^n} \right\rfloor,\]
and $S_c$ be the correct sum of $A$ and $B$ in 1’s complement.

Case 0: $A>B\geq 0$
\[S = A_1 + B_1 = A +B =S_c\]

Case 1: $A\geq 0>B\land |B|<A$
\[S = A_1 + B_1 = 2^n-1+A-|B|\]
\[R=A-|B|,\quad C=1\]
\[S_c=A-|B|=R+C\]

Case 2: $0\geq A>B$
\[S=A_1+B_1=2^{n+1}-2-|A|-|B|\]
\[R=2^n-2-|A|-|B|,\quad C=1\]
\[S_c=2^n-1-|A|-|B|=R+C\]
\end{proof}

If the sum of two positive numbers exceeds $2^{N-1}-1$, it overflows into the negative range; if the sum of two negative numbers is less than $-2^{N-1}$, it overflows into the positive range. This makes overflow detection straightforward. 
\sssc{2’s complement}
The nonnegative numbers are the same as those in sign and magnitude; the negative numbers invert all bits of its absolute value and add $1$. 

It can represent numbers range from $-2^{N-1}$ to $2^{N-1}-1$. It has only one zero.

The arithmetic is the easiest to compute.

The addition can be computed the same as unsigned numbers. If the sum of two positive numbers exceeds $2^{N-1}-1$, it overflows into the negative range; if the sum of two negative numbers is less than $-2^{N-1}$, it overflows into the positive range. This makes overflow detection straightforward. 

It is the most commonly used representation for signed numbers in computers.
\ssc{Binary Codes}
\sssc{Binary-coded decimal (BCD)}
Binary-coded decimal (BCD), or more explicitly 8-4-2-1 BCD, is a way to represent decimal digits ($0$ to $9$) in binary, in which each decimal digit is encoded separately using 4 bits (a nibble).

There are several other possible sets of binary codes for the ten decimal digits. A $k$-bit ($k\geq 4$) weighted code (in decimal) has the property that if the weights are $w_{k-1}, w_{k-2}, \ldots w_0$ (where for all $0\leq i<j<k$, $w_i<w_j$), the code $a_{k-1}a_{k-2}\ldots a_0$ represents a decimal number $N$, then
\[N = \sum_{n=0}^{k-1}w_na_n.\]

Below shows the BCD and other commonly used binary codes:
\begin{longtable}[c]{|c|c|c|c|c|c|}
\hline
Decimal Digit & 8-4-2-1 Code (BCD) & 6-3-1-1 Code & Excess-3 Code & 2-out-of-5 Code & Gray Code\\\hline
0 & 0000 & 0000 & 0011 & 00011 & 0000\\\hline
1 & 0001 & 0001 & 0100 & 00101 & 0001\\\hline
2 & 0010 & 0011 & 0101 & 00110 & 0011\\\hline
3 & 0011 & 0100 & 0110 & 01001 & 0010\\\hline
4 & 0100 & 0101 & 0111 & 01010 & 0110\\\hline
5 & 0101 & 0111 & 1000 & 01100 & 1110\\\hline
6 & 0110 & 1000 & 1001 & 10001 & 1010\\\hline
7 & 0111 & 1001 & 1010 & 10010 & 1011\\\hline
8 & 1000 & 1011 & 1011 & 10100 & 1001\\\hline
9 & 1001 & 1100 & 1100 & 11000 & 1000\\\hline
\end{longtable}\FB

\begin{itemize}
\item\tb{8-4-2-1 Code (BCD)}: Each decimal digit is directly mapped to its binary form, which makes it easy to convert between decimal numbers and binary.
\item\tb{6-3-1-1 Code}: Sometimes makes it easier to design display drivers or simplify logic circuits.
\item\tb{Excess-3 Code}: It's sefl-complementing, i.e. the complement of it is the 9’s complement of the number. 
\item\tb{2-out-of-5 Code}: Always has exactly 2 ones.
\item\tb{Gray Code}: Each step changes only one bit, which minimizes transition errors for sensors, counters, or rotary encoders.
\eit
\sssc{Character Encoding}
Many applications of computers require the processing of data which contains numbers, letters, and other symbols. In order to transmit such data to or from a computer or store it internally in a computer, each character must be represented by a binary code.

Common character encodings:
\bit
\item\tb{ASCII code (American Standard Code for Information Interchange)}: A 7-bit code, so 128 different code combinations are available.
\item\tb{Unicode / The Unicode Standard (TUS) / UTF-8}: For international characters (like 中文, emojis, etc.). The Unicode Standard itself defines three encodings: UTF-8, UTF-16, and UTF-32, which represent characters in 8, 16, 32 bytes respectively. UTF-8 is the most widely used, in part due to its backwards-compatibility with ASCII.
\eit
\section{Boolean Algebra}
\subsection{Introduction}
The basic mathematics needed for the study of logic design of digital systems is Boolean algebra. Boolean algebra was introduced by George Boole in his first book The Mathematical Analysis of Logic (1847), and set forth more fully in his An Investigation of the Laws of Thought (1854).

Switching devices are essentially two-state devices (e.g. switches which are open or closed and transistors with high or low output voltages). Consequently, we will emphasize the special case of Boolean algebra in which all of the variables assume only one of two values, 0 (false) or 1 (true), called Boolean variables; this two-valued Boolean algebra is also called switching algebra.

In a switch circuit, 0 (usually) represents an open switch, and 1 represents a closed circuit. In general, 0 and 1 can be used to represent the two states in any binary-valued system.

A Boolean function is a logical operation performed on one or more binary inputs that produces a single binary output.

A logic gate is a device that performs a Boolean function. Below, electronic symbols follow ANSI standards.
\subsection{Logic Operations}
\sssc{NOT (Negation / Inversion / Complement)}
\begin{itemize}
\item Symbol: $A'$, $\neg A$, $\mathord{\sim}A$, or $\ol{A}$
\item Definition: Invert the value.
\item Truth Table:
\begin{longtable}[c]{|m|m|}
\hline
A & A'\\\hline
0 & 1\\\hline
1 & 0\\\hline
\end{longtable}
\item Logic gate: \esym{not port}
\eit 
\sssc{AND (Conjunction / Logic Multiplication)}
\begin{itemize}
\item Symbol: $A \cdot B$, $A*B$, or $AB$
\item Definition: True if both inputs are true and false otherwise.
\item Truth Table:
\begin{longtable}[c]{|m|m|m|}
\hline
A & B & A\cdot B\\\hline
0 & 0 & 0\\\hline
1 & 0 & 0\\\hline
0 & 1 & 0\\\hline
1 & 1 & 1\\\hline
\end{longtable}
\item Logic gate: \esym{and port}
\eit
\sssc{OR (Disjunction / Logic Addition / Inclusive OR)}
\begin{itemize}
\item Symbol: $A + B$
\item Definition: True if at least one input is true and false otherwise.
\item Truth Table:
\begin{longtable}[c]{|m|m|m|}
\hline
A & B & A+B\\\hline
0 & 0 & 0\\\hline
1 & 0 & 1\\\hline
0 & 1 & 1\\\hline
1 & 1 & 1\\\hline
\end{longtable}
\item Logic gate: \esym{or port}
\eit
\sssc{XOR (Exclusive-OR)}
\begin{itemize}
\item Symbol: $A \oplus B$
\item Definition: $A'B+AB'$
\item Truth Table:
\begin{longtable}[c]{|m|m|m|}
\hline
A & B & A\oplus B\\\hline
0 & 0 & 0\\\hline
1 & 0 & 1\\\hline
0 & 1 & 1\\\hline
1 & 1 & 0\\\hline
\end{longtable}
\item Logic gate: \esym{xor port}
\eit
\sssc{NAND (Not AND)}
\begin{itemize}
\item Definition: $(AB)'$
\item Truth Table:
\begin{longtable}[c]{|m|m|m|}
\hline
A & B & (A\cdot B)'\\\hline
0 & 0 & 1\\\hline
1 & 0 & 1\\\hline
0 & 1 & 1\\\hline
1 & 1 & 0\\\hline
\end{longtable}
\item Logic gate: \esym{nand port}
\eit
\sssc{NOR (Not OR)}
\begin{itemize}
\item Definition: $(A+B)'$
\item Truth Table:
\begin{longtable}[c]{|m|m|m|}
\hline
A & B & (A+B)'\\\hline
0 & 0 & 1\\\hline
1 & 0 & 0\\\hline
0 & 1 & 0\\\hline
1 & 1 & 0\\\hline
\end{longtable}
\item Logic gate: \esym{nor port}
\eit
\sssc{XNOR ((Logic) equivalence / Exclusive NOR)}
\begin{itemize}
\item Symbol: $A\equiv B$ or $A\odot B$
\item Definition: $(A\oplus B)'$
\item Truth Table:
\begin{longtable}[c]{|m|m|m|}
\hline
A & B & (A\oplus B)'\\\hline
0 & 0 & 1\\\hline
1 & 0 & 0\\\hline
0 & 1 & 0\\\hline
1 & 1 & 1\\\hline
\end{longtable}
\item Logic gate: \esym{xnor port}
\eit
\ssc{Boolean Arithmetic}
A Boolean expression is formed by application of the logic operations to one or more Boolean variables or constants. The simplest expressions consist of a single constant or variable or its complement, such as 0, X, or Y′, which are called "literals".

In a Boolean expression, parentheses are added as needed to specify the order in which the operations are performed; when parentheses are omitted, complementation is performed first and then AND and then OR; while the precedence of XOR and XNOR varies in context.

A Boolean function or a switching function is a function of which the domain is $\{1,0\}^n$ in which $n\in\mathbb{N}$ and the codomain is $\{1,0\}$.

A truth table, also called a table of combinations, specifies the corresponding output values for all possible combinations of input values for a Boolean function. A truth table for an $n$-variable Boolean function will have $2^n$ rows.
\ssc{Theorems}
\sssc{Idempotent Laws}
\[X + X = X,\quad X\cdot X = X.\]
\sssc{Involution Law}
\[(X′)′ = X.\]
\sssc{Laws of Complementarity}
\[X + X′ = 1 ,\quad X\cdot X′ = 0 .\]
\sssc{Commutativity}
AND, OR, XOR, NAND, NOR, and XNOR are commutative.
\sssc{Associativity}
AND, OR, XOR, NAND, NOR, and XNOR are associative.
\sssc{Distributivity}
\bit
\item AND is distributive over OR and XOR.
\item OR is distributive over AND and XOR.
\item XOR is distributive over AND and OR.
\eit
\sssc{DeMorgan’s Laws}
\[(\sum_{i=1}^nX_i)′=\prod_{i=1}^nX_i',\quad (\prod_{i=1}^nX_i)'=\sum_{i=1}^nX_i'.\]
\sssc{Duality Principle}
If a Boolean equation is true, you can get another true equation, called its dual, by interchanging AND and OR and interchanging 0 and 1 everywhere.
\sssc{Uniting Theorems}
\[XY+XY'=X,\quad (X+Y)(X+Y')=X.\]
\sssc{Absorption Theorems}
\[X+XY=X,\quad X(X+Y)=X.\]
\sssc{Elimination Theorems}
\[X+X'Y=X+Y,\quad X(X'+Y)=XY.\]
\sssc{Consensus Theorems}
The consensus theorems involve eliminate one term from an expression in SOP or POS form, in which the eliminated term is called the consensus term.
\[XY+X′Z+YZ=XY+X′Z.\]
\begin{proof}
\[\begin{aligned}
XY+X′Z+YZ&=XY+X'Z+(X+X')YZ\\
&=XY+X'Z+XYZ+X'YZ\\
&=XY+X′Z.
\end{aligned}\]
\end{proof}
\[(X+Y)(X′+Z)(Y+Z)=(X+Y)(X′+Z).\]
\begin{proof}
\[\begin{aligned}
(X+Y)(X′+Z)(Y+Z)&=(X+Y)(X'+Z)(X+X')(Y+Z)\\
&=(X+Y)(X'+Z)(X+Y+Z)(X'+Y+Z)\\
&=(X+Y)(X′+Z).
\end{aligned}\]
\end{proof}
\sssc{Theorem of Combination of Distributivity and Consensus Theorem}
\[(X+Y)(X'+Z)=XZ+X'Y\]
\begin{proof}
\[(X+Y)(X'+Z)=0+XZ+X'Y+YZ=XZ+X'Y\]
\end{proof}
\sssc{Axiom of Equality}
For an one-to-one Boolean function $f$, a Boolean expression $A$ equals another Boolean expression $B$ if and only if $f(A)$ equals $f(B)$.
\ssc{Sum-of-Products (SOP) and Product-of-Sums (POS) forms}
\bit
\item\Tb{Sum-of-products (SOP) form}: An expression is said to be in SOP form if it consists of a sum (OR) of product (AND) or single variable terms, in which it is called to be degenerate when some of the terms are single variables. Every Boolean expression can be expressed in SOP form.
\item\Tb{Product-of-sums (POS) form}: An expression is said to be in POS form if it consists of a product (AND) of sum (OR) or single variable terms, in which it is called to be degenerate when some of the terms are single variables. Every Boolean expression can be expressed in POS form.
\item\Tb{Minimal SOP form}: The SOP form of a Boolean expression that has the fewest number of terms out of all SOP form of the expression.
\item\Tb{Minimal POS form}: The POS form of a Boolean expression that has the fewest number of terms out of all POS form of the expression.
\eit
\ssc{Minterm and Maxterm Expansions, Canonical Expansions, or Standard Expansion}
\sssc{Minterm expansion, canonical SOP, or standard SOP}
The ON-set of a Boolean function $f$ is the set of all input combinations such that $f$ of them is $1$. Each element in the ON-set of $f$ corresponds to a row in the truth table of $f$ in which the output is $1$.

A minterm of a Boolean function $f\colon\{1,0\}^n\to\{1,0\}$, often denoted as $m_i$ for the input combination in the $i$th row of the truth table of $f$ that is in the ON-set of $f$, is defined for any input combinations in the ON-set of $f$ as
\[m_i=\prod_{k=1}^ny_k,\]
in which $y_k$ is defined as the $k$th input variable, i.e. $x_k$, if the $k$th input in that input combination is $1$ and as the complement of the $k$th input variable, i.e. $(x_k)'$, if the $k$th input in that input combination is $0$.

Minterm expansion, canonical SOP, or standard SOP is an expression of a Boolean function as a sum of minterms of it. Let $S$ be the set of all integer $i$ such that the input combination in the $i$th row of the truth table of $f$ is in the ON-set of $f$. Then the minterm expansion, canonical SOP, or standard SOP of $f$ is
\[f=\sum_{i\in S}m_i,\]
also denoted as
\[f=\sum m(i\in S).\]

For a given Boolean function, there exists a unique minterm expansion of it.
\sssc{Maxterm expansion, canonical POS, or standard POS}
The OFF-set of a Boolean function $f$ is the set of all input combinations such that $f$ of them is $0$. Each element in the OFF-set of $f$ corresponds to a row in the truth table of $f$ in which the output is $0$.

A maxterm of a Boolean function $f\colon\{1,0\}^n\to\{1,0\}$, often denoted as $M_i$ for the input combination in the $i$th row of the truth table of $f$ that is in the OFF-set of $f$, is defined for any input combinations in the OFF-set of $f$ as
\[M_i=\sum_{k=1}^ny_k,\]
in which $y_k$ is defined as the $k$th input variable, i.e. $x_k$, if the $k$th input in that input combination is $0$ and as the complement of the $k$th input variable, i.e. $(x_k)'$, if the $k$th input in that input combination is $1$.

Maxterm expansion, canonical POS, or standard POS is an expression of a Boolean function as a product of maxterms of it. Let $T$ be the set of all integer $i$ such that the input combination in the $i$th row of the truth table of $f$ is in the OFF-set of $f$. Then the maxterm expansion, canonical POS, or standard POS of $f$ is
\[f=\prod_{i\in T}M_i,\]
also denoted as 
\[f=\prod M(i\in T).\]

For a given Boolean function, there exists a unique maxterm expansion of it.
\sssc{Conversion between function and its complement}
Let $f$ be a Boolean function, the complement of it, denoted as $f'$, is defined as a Boolean function with the same domain as $f$ such that
\[f'(x)=\begin{cases}1,\quad & \tx{if\ }f(x)=0\\0,\quad & \tx{if\ }f(x)=1\end{cases}.\]

Let $f\colon D\to\{1,0\}$ be a Boolean function with ON-set $S$, OFF-set $T=D\setminus S$, minterm expansion
\[f=\sum_{i\in S}m_i,\]
and maxterm expansion
\[f=\prod_{i\in T}M_i.\]

Then, the complement $f'$ of it has ON-set $T$, OFF-set $S$, minterm expansion 
\[f'=\sum_{i\in T}m_i,\]
and maxterm expansion
\[f'=\prod_{i\in S}M_i.\]
\ssc{Incompletely Specified Boolean Functions (ISF) or Don’t-care Functions}
A (completely specified) Boolean function $F\colon\{0,1\}^n \to \{0,1\}$ gives an output $0$ or $1$ for every one of the $2^n$ input combinations. Canonical expansions only apply to completely specified functions.

An incompletely specified function (ISF) or a don’t-care function is a Boolean function but in which for some input combinations, the output is not defined or irrelevant, denoted as don’t-care conditions or $d$. The definition of ON-set and OFF-set of an ISF is the same as completely specified function; the Don’t-Care set or DC-set of an ISF is the set of all don’t-care conditions. When simplifying an ISF, the output for the don’t-care conditions can be assigned as either $0$ or $1$, so the assignment is chosen to yield a simpler minimal SOP or POS.
\ssc{Boolean Vector Functions or Boolean Multi-output Functions}
A Boolean vector function or a Boolean multi-output function is a function $f\colon\{1,0\}^n\to\{1,0\}^m$. A Boolean vector function can be specified with truth table or as a tuple of $m$ Boolean functions.
