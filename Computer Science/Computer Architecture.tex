\documentclass[a4paper,12pt]{report}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{3}
\input{/usr/share/LaTeX-ToolKit/template.tex}
\begin{document}
\title{Computer Architecture}
\author{沈威宇}
\date{\temtoday}
\titletocdoc
\ch{Computer Architecture}


\sct{Computer Arithmetic}
\ssc{Signed Number}
Suppose you have $N$ bits to present a signed number. There's three common method:
\sssc{Sign and magnitude}
The MSB represents sign, in which $0$ represents positive and $1$ represents negative; the remaining represents magnitude. 

It can represent numbers range from $-(2^{N-1}-1)$ to $2^{N-1}-1$. It has two zero ($+0$ and $-0$).

It might be the easiest to read, but its arithmetic is the hardest to compute.
\sssc{1's complement}
The nonnegative numbers are the same as those in sign and magnitude; the negative numbers invert all bits of its absolute value, i.e. $(2^N-1)$ minus its absolute value, that is, if a negative integer $B$ written in 1's complement is
\[B=b_{N-1}b_{N-2}\ldots b_1b_0,\]
then
\[B=-2^{N-1}+1+\sum_{i=0}^{N-2}b_i2^i.\]

It can represent numbers range from $-(2^{N-1}-1)$ to $2^{N-1}-1$. It has two zero ($+0$ and $-0$). 

Its arithmetic is easier than sign and magnitude and harder than 2's complement to compute. 

The negation can be computed by inverting all bits, that is, subtracting it from $2^N-1$.

The addition can be computed the same as unsigned numbers; however, if the sum had a carry out from the MSB, we must add it back to the LSB, called the "end-around carry (EAC)".
\begin{proof}
Assume no overflow conditions.

Suppose we want to add two $n$-bit numbers $A$ and $B$, and $A$ and $B$ in 1's complement are $A_1$ and $B_1$ (treated as unsigned). Without loss of generality, assume $A\geq B$.

Let:
\[S = A_1 + B_1,\quad R=S \mod 2^N, \quad C=\left\lfloor\frac{S}{2^N}\right\rfloor,\]
and $S_c$ be the correct sum of $A$ and $B$ in 1's complement (treated as unsigned).

Case 0: $A,B\geq 0$
\[S =A_1+B_1=A+B=S_c\]

Case 1: $A\geq 0>B\land |B|\leq A$
\[S =A_1+B_1=2^N-1+A-|B|\]
\[R=A-|B|-1,\quad C=1\]
\[S_c=A-|B|=R+C\]

Case 2: $A\geq 0>B\land |B|\geq A$
\[S =A_1+B_1=2^N-1+A-|B|=S_c=R\]

Case 3: $0\geq A\geq B$
\[S=A_1+B_1=2^{N+1}-2-|A|-|B|\]
\[R=2^N-2-|A|-|B|,\quad C=1\]
\[S_c=2^N-1-|A|-|B|=R+C\]
\end{proof}

If the sum of two positive numbers is greater than $2^{N-1}-1$, it overflows into the negative range; if the sum of two negative numbers is less than $-2^{N-1}+1$, it overflows into the positive range. This makes overflow detection straightforward.

The subtraction can be computed the same as unsigned numbers; however, if the difference had a borrow out from the MSB, we must subtract it back to the LSB, called the "end-around borrow (EAB)".
\begin{proof}
Assume no overflow conditions.

Suppose we want to subtract a $n$-bit number $B$ from another $n$-bit number $A$, and $A$ and $B$ in 1's complement are $A_1$ and $B_1$ (treated as unsigned).

Let:
\[S = A_1 - B_1,\quad R=S \mod 2^N, \quad C=\left\lfloor\frac{S}{2^N}\right\rfloor,\]
and $S_c$ be the correct sum of $A$ and $B$ in 1's complement (treated as unsigned).

Case 0: $A\geq B\geq 0$
\[S=A_1-B_1=A-B=S_c\]

Case 1: $B\geq A\geq 0$
\[S=A_1-B_1=2^N-1-(B-A)\]
\[R=B-A+1,\quad C=1\]
\[S_c=B-A=R-C\]

Case 2: $A\geq 0>B$
\[S=A_1-B_1=A-\qty(2^N-1-|B|)\]
\[R=A+|B|+1,\quad C=1\]
\[S_c=A+|B|=R-C\]

Case 3: $B\geq 0>A$
\[S=A_1-B_1=2^N-1-|A|-B=R=S_c\]

Case 4: $0>A\geq B$
\[S=A_1-B_1=2^N-1-|A|-\qty(2^N-1-|B|)=|B|-|A|=R=S_c\]

Case 5: $0>B>A$
\[S=A_1-B_1=2^N-1-\qty(2^N-1-|A|-\qty(2^N-1-|B|))=2^N-1+|A|-|B|\]
\[R=|A|-|B|+1,\quad C=1\]
\[S_c=|A|-|B|=R-C\]
\end{proof}

If the difference of a positive number and a negative number is greater than $2^{N-1}-1$, it overflows into the negative range; if the difference of a negative number and a positive number is less than $-2^{N-1}+1$, it overflows into the positive range. This makes overflow detection straightforward.
\sssc{2's complement}
The nonnegative numbers are the same as those in sign and magnitude; the negative numbers invert all bits of its absolute value and add $1$, i.e. $2^N$ minus its absolute value, where $-2^{N-1}$ is only MSB being $1$ and others being $0$, that is, if a negative integer $B$ written in 1's complement is
\[B=b_{N-1}b_{N-2}\ldots b_1b_0,\]
then
\[B=-2^{N-1}+\sum_{i=0}^{N-2}b_i2^i.\]
\begin{proof}
\[\ba
B&=-|B|=-\qty(\sum_{i=0}^{n-2}(1-b_i)+1)\\
&=-\frac{2^{n-1}-1}{2-1}-1+\sum_{i=0}^{n-2}b_i2^i\\
&=-2^{n-1}+\sum_{i=0}^{n-2}b_i2^i
\ea\]
\end{proof}

It can represent numbers range from $-2^{N-1}$ to $2^{N-1}-1$. It has only one zero.

Its arithmetic is the easiest to compute. It is the most commonly used representation for signed numbers in computers.

The negation can be computed by inverting all bits and add $1$, that is, subtracting it from $2^N$.
\begin{proof}
Let negative integer $B$ written in 2's complement be
\[B=b_{n-1}b_{n-2}\ldots b_1b_0,\]
that is,
\[B=-2^{n-1}+\sum_{i=0}^{n-2}b_i2^i.\]
The negation of it, which is positive, is
\[\ba
-B&=2^{n-1}-\sum_{i=0}^{n-2}b_i2^i\\
&=2^{n-1}+\sum_{i=0}^{n-2}(1-b_i)2^i-\sum_{i=0}^{n-2}2^i\\
&=2^{n-1}+\sum_{i=0}^{n-2}(1-b_i)2^i-\frac{2^{n-1}-1}{2-1}\\
&=\sum_{i=0}^{n-2}(1-b_i)2^i+1
\ea\]
\end{proof}

The addition can be computed the same as unsigned numbers.

If the sum of two positive numbers is greater than $2^{N-1}-1$, it overflows into the negative range; if the sum of two negative numbers is less than $-2^{N-1}$, it overflows into the positive range. This makes overflow detection straightforward.

The subtraction can be computed the same as unsigned numbers.

If the difference of a positive number and a negative number is greater than $2^{N-1}-1$, it overflows into the negative range; if the difference of a negative number and a positive number is less than $-2^{N-1}$, it overflows into the positive range. This makes overflow detection straightforward.
\ssc{Binary Codes}
\sssc{Binary-coded decimal (BCD)}
Binary-coded decimal (BCD), or more explicitly 8-4-2-1 BCD, is a way to represent decimal digits ($0$ to $9$) in binary, in which each decimal digit is encoded separately using 4 bits (a nibble). There are several other possible sets of binary codes for the ten decimal digits.

A $k$-bit ($k\geq 4$) weighted code has the property that if the weights are integers $w_{k-1}, w_{k-2}, \ldots w_0$ (in decimal, and where for all $0\leq i<j<k$, $w_i<w_j$), the code $a_{k-1}a_{k-2}\ldots a_0$, where $a_i\in\{0,1\}$, represents number $N$, then
\[N = \sum_{n=0}^{k-1}w_na_n.\]
If a number $N$ has more than one possible codes in a specific set of weights, the one such that the unsigned binary number presented by the code is least is usually used. A such $k$-bit weighted code can represent up to $\sum_{n=1}^{k-1}w_n$.

Below shows the BCD and other commonly used binary codes:
\begin{longtable}[c]{|c|c|c|c|c|c|}
\hline
Decimal Digit & 8-4-2-1 Code (BCD) & 6-3-1-1 Code & Excess-3 Code & 2-out-of-5 Code & Gray Code\\\hline
0 & 0000 & 0000 & 0011 & 00011 & 0000\\\hline
1 & 0001 & 0001 & 0100 & 00101 & 0001\\\hline
2 & 0010 & 0011 & 0101 & 00110 & 0011\\\hline
3 & 0011 & 0100 & 0110 & 01001 & 0010\\\hline
4 & 0100 & 0101 & 0111 & 01010 & 0110\\\hline
5 & 0101 & 0111 & 1000 & 01100 & 1110\\\hline
6 & 0110 & 1000 & 1001 & 10001 & 1010\\\hline
7 & 0111 & 1001 & 1010 & 10010 & 1011\\\hline
8 & 1000 & 1011 & 1011 & 10100 & 1001\\\hline
9 & 1001 & 1100 & 1100 & 11000 & 1000\\\hline
\end{longtable}\FB

\begin{itemize}
\item\tb{8-4-2-1 Code (BCD)}: Each decimal digit is directly mapped to its binary form, which makes it easy to convert between decimal numbers and binary.
\item\tb{6-3-1-1 Code}: Sometimes makes it easier to design display drivers or simplify logic circuits.
\item\tb{Excess-3 Code}: It's sefl-complementing, i.e. the complement of it is the 9's complement of the number. 
\item\tb{2-out-of-5 Code}: Always has exactly 2 ones.
\item\tb{Gray Code}: Each step changes only one bit, which minimizes transition errors for sensors, counters, or rotary encoders.
\eit
\sssc{Character Encoding}
Many applications of computers require the processing of data which contains numbers, letters, and other symbols. In order to transmit such data to or from a computer or store it internally in a computer, each character must be represented by a binary code.

Common character encodings include:
\bit
\item\tb{ASCII code (American Standard Code for Information Interchange)}: A 7-bit code, so 128 different code combinations are available.
\item\tb{Unicode or the Unicode Standard (TUS)}: Includes international characters, symbols, etc. such as those in Arabic, CJK Unified Ideographs, and Emoticons. The Unicode Standard itself defines three encodings: UTF-8, UTF-16, and UTF-32. UTF-8 is the most widely used, in part due to its backwards-compatibility with ASCII.
\eit
\end{document}