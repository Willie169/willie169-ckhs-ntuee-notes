\documentclass[a4paper,12pt]{article}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{3}
\input{/usr/share/LaTeX-ToolKit/template.tex}
\begin{document}
\title{Theory of Computation}
\author{沈威宇}
\date{\temtoday}
\titletocdoc
\section{Theory of Computation (TOC)}
\ssc{Formal Language Theory}
\sssc{Alphabet}
An alphabet $\Sigma$ of a formal language is a finite set of symbols, called characters or symbols.
\sssc{String or word}
Strings (or words) over alphabet $\Sigma$ are defined as follows:
\begin{itemize}
\item The empty sequence is a string, called empty string and denoted by $\varepsilon$.
\item A single character $a\in\Sigma$ is a string.
\item A concatenation of strings is a string, denoted by writing them side by side.
\end{itemize}
The length of a string, denoted by $|\cdot|$, is defined as follows:
\begin{itemize}
\item The empty string $\varepsilon$ has length $0$.
\item A single character $a\in\Sigma$ has length $1$.
\item A string of length $m$ concatenated with a string of length $n$ yields a string of length $m+n$.
\end{itemize}
\sssc{Kleene star, Kleene operator, or Kleene closure of an alphabet}
Given an alphabet $V$, define
\[V^0 = \{\varepsilon\},\]
and define recursively for $i\in\mathbb{N}$:
\[V^i = \{wv \mid w\in V^{i-1} \land v\in V \}.\]
The Kleene star on $V$ is defined as
\[V^* = \bigcup_{i\in\mathbb{N}_0} V^i.\]
The Kleene plus on $V$ is defined as
\[V^+ = \bigcup_{i\in\mathbb{N}} V^i.\]
\sssc{Formal language}
A formal language, or, when the context is clear, language, $L$ over $\Sigma$ is any subset of $\Sigma^*$. A word $w\in\Sigma^*$ is called well-formed if $w\in L$.
\sssc{Kleene star, Kleene operator, or Kleene closure of a language}
Given a language $V$, define
\[V^0 = \{\varepsilon\},\]
and define recursively for $i\in\mathbb{N}$:
\[V^i = \{wv \mid w\in V^{i-1} \land v\in V \}.\]
The Kleene star on $V$ is defined as
\[V^* = \bigcup_{i\in\mathbb{N}_0} V^i.\]
The Kleene plus on $V$ is defined as
\[V^+ = \bigcup_{i\in\mathbb{N}} V^i.\]
\sssc{Concatenation of languages}
Given two formal languages $L_0,L_1$ over the same alphabet, the concatenation of them, denoted by $L_0L_1$ or $L_0\cdot L_1$, is defined as
\[L_0L_1=\{xy\mid x\in L_0\land y\in L_1\}.\]
\sssc{(Unrestricted or type 0) (formal) grammar}
A grammar can be defined as a four-tuple
\[G=(V,\Sigma,R,S)\]
where
\bit
\item $V$ is a set of nonterminal symbols, abstract symbols that represent syntactic categories,
\item $\Sigma$ is a set of terminal symbols, the actual characters that can appear in a string, i.e., alphabet, with $V\cap\Sigma=\varnothing$,
\item $R$ is a set of production rules (also called rewrite rules), which are pairs of a nonempty string of nonterminal symbols and terminal symbols and a string of nonterminal symbols and terminal symbols, i.e.,
\[R\subseteq (V\cup\Sigma)^*V(V\cup\Sigma)^*\times (V\cup\Sigma)^*,\]
in which a rule is denoted as
\[A\mapsto a\]
for $A\in(V\cup\Sigma)^+\land a\in(V\cup\Sigma)^*$ and called $A$ rewrites to $a$. For any $v,w\in(V\cup\Sigma)^*$ and $A\mapsto a$, we write $vAw\vdash vaw$. $\vdash^*$ is the reflexive and transitive closure of the relation $\vdash$, that is, if
\[w_0\vdash w_1\vdash\ldots\vdash w_k,\]
then
\[w_0\vdash^*w_k,\]
\item $S\in V$ is a start symbol.
\eit
The language defined by a grammar $G$, i.e., all $w\in\Sigma^*$ such that $S\vdash^*w$, is denoted as $L(G)$.
\sssc{Context-free grammar (CFG) or type 2 grammar}
A context-free grammar is a grammar of which the production rules are pairs of a nonterminal symbol and a string of nonterminal symbols and terminal symbols, i.e.,
\[R\subseteq V\times (V\cup\Sigma)^*.\]
\sssc{Context-free language (CFL) or type 2 language}
A context-free language is a language defined by a context-free grammar.
\sssc{Deterministic context-free language (DCFL)}
A language is a deterministic context-free language iff there exists a deterministic pushdown automaton (DFPA) that recognize it.
\sssc{Regular grammar or type 3 grammar}
A regular grammar is a grammar of which either all the production rules are right-linear or all the production rules are left-linear.

A production rule is right-linear if it is in the set
\[V\times\Sigma\cup V\Sigma^*\cup\{\varepsilon\}.\]

A production rule is left-linear if it is in the set
\[V\times\Sigma\cup \Sigma^*V\cup\{\varepsilon\}.\]
\sssc{Regular language or type 3 language}
A regular language is a language defined by a regular grammar.

The collection of regular languages over an alphabet $\Sigma$ can be defined recursively with:
\begin{itemize}
\item The empty language $\varnothing$ is a regular language.
\item For each $a\in\Sigma$, the singleton $\{a\}$ is a regular language.
\item If $A$ is a regular language, then $A^*$ is a regular language.
\item If $A$ and $B$ are regular languages, then $A\cup B$ and $A\cdot B$ are regular languages.
\item No other languages over $\Sigma$ are regular.
\end{itemize}
\sssc{Context-sensitive grammar (CSG) or type 1 grammar}
A context-sensitive grammar is a grammar such that all production rules are either $S\mapsto\varepsilon$ or in the form
\[vAw\mapsto vaw\]
where $A\in V$, $v,w\in(V\cup\Sigma\setminus\{S\})^*$, and $a\in(V\cup\Sigma\setminus\{S\})^+$.
\sssc{Context-sensitive language (CFL) or type 1 language}
A context-sensitive language is a language defined by a context-sensitive grammar.
\sssc{Recursively enumerable (RE), recognizable, partially decidable, semidecidable, Turing-acceptable, Turing-recognizable, or type 0 language}
A recursively enumerable language is a language defined by an unrestricted grammar.
\ssc{Automata Theory}
\sssc{Automata}
An automaton (plural: automata) can be defined as a four-tuple
\[M=(\Sigma,S,s_0,\delta),\]
where
\bit
\item $\Sigma$ is an input alphabet,
\item $S$ is a set of all states,
\item $s_0\in S$ is the starting state (also called start state),
\item $\delta$ is a next-state function (also called transition function), which,
\bit
\item For deterministic automaton, is a partial function
\[\delta\colon S\times\Sigma\to S\]
mapping pairs of current state (also called present state) and input to successor states (also called next states),
\item For nondeterministic automaton, is a partial function
\[\delta\colon S\times\Sigma\to 2^S\]
mapping pairs of current state (also called present state) and input to sets of all possible successor states (also called next states),
\eit
Unless otherwise specified, an automaton is usually considered deterministic.
\sssc{Extended transition function}
\bit
\item For deterministic automaton, the transition function $\delta$ is extended inductively into $\ol{\delta}\colon S\times\Sigma^*\to S$. For the empty string $\varepsilon$, $\ol{\delta}(s,\varepsilon)=s$ for all states $s$, and for strings $wa$ where $a$ is the last symbol and $w$ is the (possibly empty) rest of the string,
\[\ol{\delta}(s,wa)=\delta(\ol{\delta}(s,w),a).\]
\item For nondeterministic automaton, the transition function $\delta$ is extended inductively into $\ol{\delta}\colon S\times\Sigma^*\to 2^S$. For the empty string $\varepsilon$, $\ol{\delta}(s,\varepsilon)=\{s\}$ for all states $s$, and for strings $wa$ where $a$ is the last symbol and $w$ is the (possibly empty) rest of the string,
\[\ol{\delta}(s,wa)=\bigcup_{q\in\ol{\delta}(s,w)}\delta(q,a).\]
\eit
\sssc{Computation or transitions}
Given a finite-length or infinite-length input word $w=a_1a_2\ldots\in\Sigma^*$, for each $i\in\bbN\land i\leq |w|$, called a step of the computation or a transition,
\bit
\item For deterministic automaton, the automaton transitions from $s_{i-1}$ to $s_i=\delta(s_{i-1},a_i)$, denoted $s_{i-1}\vdash s_i$.
\item For nondeterministic automaton, with $p_0=\{s_0\}$, the automaton transitions from an element $s_{i-1}$ of $p_{i-1}$ to an element $s_i$ of $p_i=\bigcup_{s\in p_{i-1}}\delta(s,a_i)$, denoted $s_{i-1}\vdash s_i$.
\eit

$\vdash^*$ is the reflexive and transitive closure of the relation $\vdash$, that is, if
\[C_0\vdash C_1\vdash\ldots\vdash C_k,\]
then
\[C_0\vdash^*C_k.\]

The final states of an automaton given an input word $w$ and a starting state $s_0$ is the states $s_n$ such that $s_0\vdash^*s_n$ and that the automaton will stop reading symbols, called halt, if its state is $s_n$ after the $n$th step, either due to $|w|=n$ for those automata that reads input word directly one-by-one or due to the automaton's own rule.
\sssc{Acceptor or recognizer}
An acceptor (also called recognizer) is an automaton with a set of accepted final state and can be defined as a five-tuple
\[M=(\Sigma,S,s_0,\delta,F),\]
where
\bit
\item $\Sigma$ is an input alphabet,
\item $S$ is a set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function,
\item $F\subseteq S$ is the set of accepted final state.
\eit
An input word $w\in\Sigma^*$ is an accepting word if there exists $f\in F$ such that $s_0\vdash^*f$. The formal language $L$ recognized by the automaton is the set of all accepting words, called the recognizable language of the acceptor.
\sssc{Transducer}
A transducer is an automaton with output and can be defined as a five-tuple
\[M=(\Sigma,\Gamma,S,s_0,\delta),\]
where
\bit
\item $\Sigma$ is an input alphabet,
\item $\Gamma$ is an output alphabet,
\item $S$ is a set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function with output, which,
\bit
\item For deterministic automaton, is a partial function
\[\delta\colon S\times\Sigma\to S\times\Gamma\]
mapping pairs of current state (also called present state) and input to pairs of successor state and output,
\item For nondeterministic automaton, is a partial function
\[\delta\colon S\times\Sigma\to 2^{S\times\Gamma}\]
mapping pairs of current state and input to sets of all possible pairs of successor state and output.
\eit
\eit
\sssc{Extended transition function with output}
Define $f\colon S\times\Gamma^*\to S$ and $g\colon S\times\Gamma^*\to\Gamma^*$ as
\[f(a,b)=a,\quad g(a,b)=b.\]
\bit
\item For deterministic transducer, the transition function with output $\delta$ is extended inductively into $\ol{\delta}\colon S\times\Sigma^*\to S\times\Gamma^*$. For the empty string $\varepsilon$, $\ol{\delta}(s,\varepsilon)=(s,\varepsilon)$ for all states $s$, and for strings $wa$ where $a$ is the last symbol and $w$ is the (possibly empty) rest of the string,
\[\ol{\delta}(s,wa)=(f(\delta(f(\ol{\delta}(s,w)),a)),g(\ol{\delta}(s,w))g(\delta(f(\ol{\delta}(s,w)),a))).\]
\item For nondeterministic transducer, the transition function with output $\delta$ is extended inductively into $\ol{\delta}\colon S\times\Sigma^*\to 2^{S\times\Gamma^*}$. For the empty string $\varepsilon$, $\ol{\delta}(s,\varepsilon)=\{(s,\varepsilon)\}$ for all states $s$, and for strings $wa$ where $a$ is the last symbol and $w$ is the (possibly empty) rest of the string,
\[\ol{\delta}(s,wa)=
\bigcup_{q\in\ol{\delta}(s,w)}\bigcup_{p\in\delta(f(q),a)}(f(p),g(q)g(p)).\]
\eit
\sssc{Finite-state machine (FSM), finite-state automaton (FSA), finite automaton, or state machine}
A finite-state machine can be defined as a five-tuple
\[M=(\Sigma,S,s_0,\delta,F),\]
where
\bit
\item $\Sigma$ is a finite input alphabet,
\item $S$ is a finite non-empty set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function,
\item $F\subseteq S$ is the set of accepted final states.
\eit
A finite-state machine reads finite-length input words.

A deterministic finite-state automaton is abbreviated to DFS, DFA, DFSA, or DFSM. A nondeterministic finite-state automaton is abbreviated to NFS, NFA, NFSA, or NFSM.

\tb{Theorem.} The collection of all recognizable languages of all finite-state machine is the collection of all regular languages.
\sssc{Finite-state transducer (FST)}
A finite-state transducer is a transducer that is also a FSA and can be defined as a six-tuple
\[M=(\Sigma,\Gamma,S,s_0,\delta,F),\]
where
\bit
\item $\Sigma$ is a finite input alphabet,
\item $\Gamma$ is an output alphabet,
\item $S$ is a finite non-empty set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function with output,
\item $F\subseteq S$ is the set of accepted final states.
\eit
A finite-state transducer reads finite-length input words.

A deterministic finite-state transducer is abbreviated to DFST. A nondeterministic finite-state automaton is abbreviated to NDFST or NFST.
\sssc{Mealy machine}
A Mealy machine is a deterministic FSM without the set of accepted final states since all final states are accepted and can be defined as a six-tuple
\[M=(\Sigma,\Gamma,S,s_0,\delta,G),\]
where
\bit
\item $\Sigma$ is a finite input alphabet,
\item $\Gamma$ is a finite output alphabet,
\item $S$ is a finite non-empty set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function without output,
\item $G$ is a next-output function (also called output function), which is a partial function
\[G\colon S\times\Sigma\to\Gamma\]
mapping pairs of current state and input to outputs.
\eit
\sssc{Moore machine}
A Moore machine is a Mealy machine whose output only depends on present state and not on input and can be defined as a six-tuple
\[M=(\Sigma,\Gamma,S,s_0,\delta,G),\]
where
\bit
\item $\Sigma$ is a finite input alphabet,
\item $\Gamma$ is a finite output alphabet,
\item $S$ is a finite non-empty set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function without output,
\item $G$ is a next-output function (also called output function), which is a partial function
\[G\colon S\to\Gamma\]
mapping current states to outputs.
\eit
\sssc{Pushdown automaton (PDA)}
A pushdown automaton accepting by final state can be defined as a seven-tuple
\[M=(\Sigma,\Gamma,S,s_0,\delta,Z,F),\]
and a pushdown automaton accepting by empty stack can be defined as a six-tuple
\[M=(\Sigma,\Gamma,S,s_0,\delta,Z),\]
where
\bit
\item $\Sigma$ is a finite input alphabet,
\item $\Gamma$ is a finite stack alphabet,
\item $S$ is a finite non-empty set of all states,
\item $s_0\in S$ is the starting state,
\item $\delta$ is a transition function, which
\bit
\item For deterministic PDA (DPDA), is a partial function
\[\delta\colon S\times(\Sigma\cup\{\varepsilon\})\times\Gamma\to S\times\Gamma^*\]
mapping triples of current state (also called present state), input or no input, and popped stack symbol to pairs of successor state and stack word to push, with the constraint that for any fixed $(s,\gamma)\in S\times\Gamma$, if there exists any $\sigma\in\Sigma$ such that $(s,\sigma,\gamma)\in D_{\delta}$, then $(s,\varepsilon,\gamma)\notin D_{\delta}$, called the no $\varepsilon$/normal conflict rule.
\item For nondeterministic PDA (NPDA), is a partial function
\[\delta\colon S\times(\Sigma\cup\{\varepsilon\})\times\Gamma\to 2^{S\times\Gamma^*}\]
mapping triples of current state (also called present state), input or no input, and popped stack symbol to set of all possible pairs of successor state and stack word to push,
\eit
\item $Z\in\Gamma$ is the initial stack symbol, 
\item $F\subseteq S$ is the set of accepted final states.
\eit
A pushdown automaton reads finite-length input words.

The stack of a PDA is a string over $\Gamma$. When the PDA pops a symbol from the stack, the leftmost symbol is removed from the stack, that is, the stack transitions from $x\gamma$ to $\gamma$ where $x\in\Gamma$ and $\gamma\in\Gamma^*$. When the PDA pushes a word $y\in\Gamma^*$ to the stack, $y$ is prepended to the left of the sequence, that is, the stack transitions from $\gamma$ to $y\gamma$ where $\gamma\in\Gamma^*$.

Given a finite-length input word $w=a_1a_2\ldots a_n\in\Sigma^*$ and a starting state $s_0\in S$ of a PDA, for each $i$th step of the computation, a PDA reads an input character $a$, when which the transition is called a normal transition, or reads an empty string, when which the transition is called a $\varepsilon$-transition, pops the leftmost symbol $x\in\Gamma$ from the stack, transitions its state according to $\delta$ from $s_{i-1}$ to $s_i$, and pushes a stack word $y\in\Gamma^*$ to the stack according to $\delta$, denoted, with the remaining input word before the transition being $av$ and the stack before the transition being $x\alpha$, for normal transition as $(s_{i-1},av,x\alpha)\vdash(s_i,v,y\alpha)$ and for $\varepsilon$-transition as $(s_{i-1},av,x\alpha)\vdash(s_i,av,y\alpha)$.

For a pushdown automaton accepting by final state, an input word $w\in\Sigma^*$ is an accepting word if $(s_0,w,Z)\vdash^*(f,\varepsilon,\gamma)$ for some $f\in F$ and $\gamma\in\Gamma^*$. For each pushdown automaton $M$ accepting by final state, the set of all accepting words is denoted as $L(M)$.

For a pushdown automaton accepting by empty stack, an input word $w\in\Sigma^*$ is an accepting word if $(s_0,w,Z)\vdash^*(s,\varepsilon,\varepsilon)$ for some $s\in S$. For each pushdown automaton $M$ accepting by empty stack, the set of all accepting words is denoted as $N(M)$.

\tb{Theorem.} For each pushdown automaton $M$ accepting by final state, there exists a pushdown automaton $M'$ accepting by empty stack such that $L(M)=N(M')$. For each pushdown automaton $M$ accepting by empty stack, there exists a pushdown automaton $M'$ accepting by final state such that $N(M)=L(M')$.

\tb{Theorem.} The collection of all recognizable languages of all pushdown automata is the collection of all context-free languages.
\sssc{Turing machine (TM)}
A Turing machine can be defined as a seven-tuple
\[M=(\Sigma,b,\Gamma,S,s_0,F,\delta)\]
where
\bit
\item $\Sigma$ is a finite input alphabet,
\item $b\notin\Sigma$ is a blank symbol,
\item $\Gamma\supseteq\Sigma\cup\{b\}$ is a finite non-empty tape alphabet,
\item $S$ is a finite non-empty set of all states,
\item $s_0\in S$ is the starting state,
\item $F\subseteq S$ is the set of accepted final states,
\item $\delta$ is a transition function, which
\bit
\item For deterministic Turing machine (DTM), is a partial function
\[\delta\colon (S\setminus F)\times\Gamma\to S\times\Gamma\times\{L,R,S\}\]
mapping pairs of current state and tape symbol at current head to triples of successor state, tape symbol to write at current head, and head movement, where $L$ means moving head one cell left, $R$ means moving head one cell right, and $S$ means not moving head.
\item For nondeterministic Turing machine (NTM), is a partial function
\[\delta\colon (S\setminus F)\times\Gamma\to 2^{S\times\Gamma\times\{L,R,S\}}\]
mapping pairs of current state and tape symbol at current head to sets of possible triples of successor state, tape symbol to write at current head, and head movement, where $L$ means moving head one cell left, $R$ means moving head one cell right, and $S$ means not moving head.
\eit
\eit
A Turing machine reads finite-length and infinite-length input words.

Given input word $w=a_1a_2\ldots$, the tape of a TM is an infinite sequence initially loaded with $w$ in a contiguous block from left to right and loaded with $b$ for the rest of the cells. Let the cell loaded with $a_i$ be of index $i$. The initial head is the cell of index 1. For one-way infinite tape, the cell of index 1 is the leftmost cell, and moving head left at that cell is defined as staying at that cell. For two-way infinite tape, there are infinite cells to both the left and right to the cell of index 1.

Given also a starting state $s_0\in S$ of the TM, for each $i$th step of the computation, the TM reads the tape symbol at the current head, transitions its state according to $\delta$ from $s_{i-1}$ to $s_i$, overwrite the symbol at the current head according to $\delta$, and move the head one cell left or right or not move the head according to $\delta$.

The TM halts when the pair of the current state (which is the final state) and the tape symbol at the current head is not in the domain of $\delta$. If the final state $s_f$ of the TM is in $F$, the halt is an accepting halt and the input word $w$ is an accepting word; otherwise, the halt is a rejecting halt, $s_f$ is a rejecting state, $w$ is a rejecting word.

\tb{Theorem.} The collection of all recognizable languages of all Turing machine is the collection of all recursively enumerable languages.
\sssc{State-transition table for FSM and FST}
A one-dimensional state-transition table lists the corresponding next states (and outputs for FST) for all allowed combinations of input character and current state in rows with each of them in a column.

A two-dimensional state-transition table consists of rows of all current states and columns of all input characters and specifies the corresponding next states (and outputs for FST) in each cell, where the cell of not allowed combinations of input and current state is typically filled with -.

The states may be represented in meaningless symbols or real meaning.
\sssc{State diagram for Moore machine}
A state diagram for Moore machine is a directes graph with
\bit
\item Each vertex being a state, normally represented by circles with symbols of states in the top half and output at the state in the bottom half.
\item Each directed edge being a transition, normally drawn as an arrow from present state to next state with the input character read on the edge.
\item The starting state is usually represented by an arrow with no origin pointing to the state or not shown.
\eit
\sssc{State diagram for Mealy machine}
A state diagram for Mealy machine is a directes graph with
\bit
\item Each vertex being a state, normally represented by circles with symbols of states.
\item Each directed edge being a transition, normally drawn as an arrow from present state to next state with the input character read on and output character of the transition on the edge.
\item The starting state is usually represented by an arrow with no origin pointing to the state or not shown.
\eit

\end{document}
